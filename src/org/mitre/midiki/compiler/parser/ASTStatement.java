/* Generated By:JJTree: Do not edit this line. ASTStatement.java */

/****************************************************************************
 *
 * Copyright (C) 2004. The MITRE Corporation (http://www.mitre.org/). All Rights Reserved.
 * Consult the LICENSE file in the root of the distribution for terms and restrictions.
 *
 *       Release: 1.0
 *       Date: 24-August-2004
 *       Author: Carl Burke
 *
 *****************************************************************************/
package org.mitre.midiki.compiler.parser;

import java.util.*;
import java.io.*;

public class ASTStatement
    extends SimpleNode
{
  public ASTStatement(int id) {
    super(id);
  }

  public ASTStatement(MKParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(MKParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }

    /* Each node has a representation in terms of instructions for
     * a hypothetical stack machine. This routine appends that
     * representation onto a list, for each of its children.
     * Instruction representation is as an op code and an argument.
     * Some instructions which want two arguments have been split
     * into separate instructions.
     * The default implementation has no effect.
     */
    public void generateCode(LinkedList buffer)
    {
        MKInstruction sttype = 
            new MKInstruction(MKInstruction.MKIN_STMT, null);
        MKInstruction ststart = 
            new MKInstruction(MKInstruction.MKIN_STTOP, null);
        MKInstruction stend = 
            new MKInstruction(MKInstruction.MKIN_STBOT, ststart);
        sttype.setLexicalHook(this);
        ststart.setLexicalHook(this);
        stend.setLexicalHook(this);
        ststart.setArgument(stend);
        buffer.addLast(sttype);
        buffer.addLast(ststart);
        if (children != null) {
            for (int i = 0; i < children.length; ++i) {
                SimpleNode n = (SimpleNode)children[i];
                if (n != null) {
                    n.generateCode(buffer);
                }
            }
        }
        buffer.addLast(stend);
    }
}
