/* Generated By:JJTree: Do not edit this line. ASTName.java */

/****************************************************************************
 *
 * Copyright (C) 2004. The MITRE Corporation (http://www.mitre.org/). All Rights Reserved.
 * Consult the LICENSE file in the root of the distribution for terms and restrictions.
 *
 *       Release: 1.0
 *       Date: 24-August-2004
 *       Author: Carl Burke
 *
 *****************************************************************************/
package org.mitre.midiki.compiler.parser;

import java.util.*;
import java.io.*;

public class ASTName extends SimpleNode implements Serializable {
    private boolean qualified;
    public void setQualified(boolean q)
    {
        qualified = q;
    }
    public boolean isQualified()
    {
        return qualified;
    }

    static public final String QUAL_DOT = ".";
    static public final String QUAL_HASH = "#";
    private String qualtype;
    public void setQualType(String q)
    {
        qualtype = q;
    }
    public String getQualType()
    {
        return qualtype;
    }

    private boolean hasargs;
    public void setHasArgs(boolean q)
    {
        hasargs = q;
    }
    public boolean hasArgs()
    {
        return hasargs;
    }

  public ASTName(int id) {
    super(id);
    qualtype = null;  // default - no qualification known yet
  }

  public ASTName(MKParser p, int id) {
    super(p, id);
    qualtype = null;  // default - no qualification known yet
  }


  /** Accept the visitor. **/
  public Object jjtAccept(MKParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }

    /* Each node has a representation in terms of instructions for
     * a hypothetical stack machine. This routine appends that
     * representation onto a list, for each of its children.
     * Instruction representation is as an op code and an argument.
     * Some instructions which want two arguments have been split
     * into separate instructions.
     * The default implementation has no effect.
     */
    public void generateCode(LinkedList buffer)
    {
        generateCode(buffer, 0);
    }

    public void generateCode(LinkedList buffer, int holdback)
    {
        MKInstruction mkin = null;
        if (children == null) return;
        // the name has some substance to it
        if (qualtype==null || qualtype.equals(QUAL_DOT)) {
            ASTDesignator ds = (ASTDesignator)children[0];
            if (ds.children != null) {
                if (ds.children[0] instanceof ASTIdentifier) {
                    ASTIdentifier idn = (ASTIdentifier)ds.children[0];
                    mkin = new MKInstruction(MKInstruction.MKIN_FCNAME,
                                             idn.getName());
                    mkin.setLexicalHook(this);
                    buffer.addLast(mkin);
                } else if (ds.children[0] instanceof ASTVariable) {
                    ASTVariable vrn = (ASTVariable)ds.children[0];
                    mkin = new MKInstruction(MKInstruction.MKIN_FCINST,
                                             vrn.getName());
                    mkin.setLexicalHook(this);
                    buffer.addLast(mkin);
                } else {
                }
            }
            if (children.length > 1) {
                ASTQualifierList ql = (ASTQualifierList)children[1];
                ql.generateForwardProbe(buffer,holdback);
            }
        } else if (qualtype.equals(QUAL_HASH)) {
            // this qualifier can only be set explicitly, since the
            // default is for a '.' qualifier.
            if (children.length > 1) {
                ASTQualifierList ql = (ASTQualifierList)children[1];
                ql.generateBackwardProbe(buffer,holdback);
            }
            ASTDesignator ds = (ASTDesignator)children[0];
            if (ds.children != null) {
                if (ds.children[0] instanceof ASTIdentifier) {
                    ASTIdentifier idn = (ASTIdentifier)ds.children[0];
                    mkin = new MKInstruction(MKInstruction.MKIN_FMNAME,
                                             idn.getName());
                    mkin.setLexicalHook(this);
                    buffer.addLast(mkin);
                } else if (ds.children[0] instanceof ASTVariable) {
                    ASTVariable vrn = (ASTVariable)ds.children[0];
                    mkin = new MKInstruction(MKInstruction.MKIN_FMINST,
                                             vrn.getName());
                    mkin.setLexicalHook(this);
                    buffer.addLast(mkin);
                } else {
                }
            }
        }
    }
}
