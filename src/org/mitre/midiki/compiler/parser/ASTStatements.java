/* Generated By:JJTree: Do not edit this line. ASTStatements.java */

/****************************************************************************
 *
 * Copyright (C) 2004. The MITRE Corporation (http://www.mitre.org/). All Rights Reserved.
 * Consult the LICENSE file in the root of the distribution for terms and restrictions.
 *
 *       Release: 1.0
 *       Date: 24-August-2004
 *       Author: Carl Burke
 *
 *****************************************************************************/
package org.mitre.midiki.compiler.parser;

import java.util.*;

public class ASTStatements extends SimpleNode {
  public ASTStatements(int id) {
    super(id);
  }

  public ASTStatements(MKParser p, int id) {
    super(p, id);
  }


    public MKContext context;

  /** Accept the visitor. **/
  public Object jjtAccept(MKParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }

    /* Each node has a representation in terms of instructions for
     * a hypothetical stack machine. This routine appends that
     * representation onto a list, for each of its children.
     * Instruction representation is as an op code and an argument.
     * Some instructions which want two arguments have been split
     * into separate instructions.
     * The default implementation has no effect.
     */
    public void generateCode(LinkedList buffer)
    {
        MKInstruction bktype = 
            new MKInstruction(MKInstruction.MKIN_BKTYPE, null);
        MKInstruction bkstart = 
            new MKInstruction(MKInstruction.MKIN_BKSTART, null);
        MKInstruction bkend = 
            new MKInstruction(MKInstruction.MKIN_BKEND, bkstart);
        bktype.setLexicalHook(this);
        bkstart.setLexicalHook(this);
        bkend.setLexicalHook(this);
        bkstart.setArgument(bkend);
        buffer.addLast(bktype);
        buffer.addLast(bkstart);
        if (context != null) context.setRef(bktype);
        if (children != null) {
            for (int i = 0; i < children.length; ++i) {
                SimpleNode n = (SimpleNode)children[i];
                if (n != null) {
                    n.generateCode(buffer);
                }
            }
        }
        buffer.addLast(bkend);
    }
}
