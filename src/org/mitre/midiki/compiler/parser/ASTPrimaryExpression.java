/* Generated By:JJTree: Do not edit this line. ASTPrimaryExpression.java */

/****************************************************************************
 *
 * Copyright (C) 2004. The MITRE Corporation (http://www.mitre.org/). All Rights Reserved.
 * Consult the LICENSE file in the root of the distribution for terms and restrictions.
 *
 *       Release: 1.0
 *       Date: 24-August-2004
 *       Author: Carl Burke
 *
 *****************************************************************************/
package org.mitre.midiki.compiler.parser;

import java.util.*;

public class ASTPrimaryExpression extends SimpleNode {
    static public final int br_lit = 1;
    static public final int br_par = 2;
    static public final int br_lst = 3;
    static public final int br_blk = 4;
    static public final int br_nam = 5;
    static public final int br_fnc = 6;
    private int branch;
    public void setBranch(int b)
    {
        branch = b;
    }
    public int getBranch()
    {
        return branch;
    }

  public ASTPrimaryExpression(int id) {
    super(id);
  }

  public ASTPrimaryExpression(MKParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(MKParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }

    /* Each node has a representation in terms of instructions for
     * a hypothetical stack machine. This routine appends that
     * representation onto a list, for each of its children.
     * Instruction representation is as an op code and an argument.
     * Some instructions which want two arguments have been split
     * into separate instructions.
     * The default implementation has no effect.
     */
    public void generateCode(LinkedList buffer)
    {
        if (branch != br_fnc) {
            if (children != null) {
                for (int i = 0; i < children.length; ++i) {
                    SimpleNode n = (SimpleNode)children[i];
                    if (n != null) {
                        n.generateCode(buffer);
                    }
                }
            }
        } else {
            // This is a method/function call. One of the features of
            // the language is the equivalence between 'fn#class(inst, ...)'
            // and 'inst.fn(...)', where class is automatically extracted
            // from the dot-qualified name and the instance is silently
            // supplied as the first argument of the method.
            // This is where we must implement that equivalence.
            if (children == null) {
                System.out.println("Method call with now child nodes!");
                return;
            }
            ASTName nm = (ASTName)children[0];
            ASTArguments ag = (ASTArguments)children[1];
            MKInstruction arity = ag.generateArity(buffer);
            arity.setLexicalHook(this);
            MKInstruction header = null;
            if ((nm.getQualType()!=null) &&
                nm.getQualType().equals(ASTName.QUAL_DOT)) {
                // add an argument for the 'this' pointer
                header =
                    new MKInstruction(MKInstruction.MKIN_ARG, null);
                header.setLexicalHook(this);
                buffer.addLast(header);
                MKInstruction thisPtr =
                    new MKInstruction(MKInstruction.MKIN_FCNAME, "_thatptr");
                thisPtr.setLexicalHook(this);
                buffer.addLast(thisPtr);
                int oldArity = ((Integer)arity.getArgument()).intValue();
                arity.setArgument(new Integer(oldArity+1));
            }
            ag.generateArguments(buffer, header);
            // now push the method reference
            nm.generateCode(buffer);
            // and generate the method call
            MKInstruction mkin = 
                new MKInstruction(MKInstruction.MKIN_METHOD, arity);
            mkin.setLexicalHook(this);
            buffer.addLast(mkin);
        }
    }
}
