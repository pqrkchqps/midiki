/* Generated By:JJTree: Do not edit this line. ASTExpressions.java */

/****************************************************************************
 *
 * Copyright (C) 2004. The MITRE Corporation (http://www.mitre.org/). All Rights Reserved.
 * Consult the LICENSE file in the root of the distribution for terms and restrictions.
 *
 *       Release: 1.0
 *       Date: 24-August-2004
 *       Author: Carl Burke
 *
 *****************************************************************************/
package org.mitre.midiki.compiler.parser;

import java.util.*;

public class ASTExpressions extends SimpleNode {
  public ASTExpressions(int id) {
    super(id);
  }

  public ASTExpressions(MKParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(MKParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }

    private MKInstruction generateArity(LinkedList buffer)
    {
        int expcount = 0;
        MKInstruction arity =
            new MKInstruction(MKInstruction.MKIN_LIST, new Integer(expcount));
        arity.setLexicalHook(this);
        if (children == null) return arity;
        ASTExpressionList al = (ASTExpressionList)children[0];
        if (al.children == null) return arity;
        for (int i = 0; i < al.children.length; ++i) {
            SimpleNode n = (SimpleNode)al.children[i];
            if (n != null) {
                expcount++;
            }
        }
        arity.setArgument(new Integer(expcount));
        buffer.addLast(arity);
        return arity;
    }

    public void generateExpressions(LinkedList buffer)
    {
        MKInstruction prev = null;
        MKInstruction elminst = null;
        ASTExpressionList al = (ASTExpressionList)children[0];
        ASTExpression atail = null;
        if (children.length>1) {
            atail = (ASTExpression)children[1];
        }
        if (al.children != null) {
            for (int i = 0; i < al.children.length; ++i) {
                SimpleNode n = (SimpleNode)al.children[i];
                if (n != null) {
                    elminst =
                        new MKInstruction(MKInstruction.MKIN_LISTELM, null);
                    elminst.setLexicalHook(this);
                    if (prev != null) prev.setArgument(elminst);
                    prev = elminst;
                    buffer.addLast(elminst);
                    n.generateCode(buffer);
                }
            }
        }
        if (atail != null) {
            elminst =
                new MKInstruction(MKInstruction.MKIN_LISTCDR, null);
            elminst.setLexicalHook(this);
            if (prev != null) prev.setArgument(elminst);
            prev = elminst;
            buffer.addLast(elminst);
            atail.generateCode(buffer);
        }
        elminst =
            new MKInstruction(MKInstruction.MKIN_ENDLIST, null);
        elminst.setLexicalHook(this);
        if (prev != null) prev.setArgument(elminst);
        prev = elminst;
        buffer.addLast(elminst);
    }

    public void generateCode(LinkedList buffer)
    {
        MKInstruction arity = null;
        if (children == null) {
            arity =
                new MKInstruction(MKInstruction.MKIN_LIST, new Integer(0));
            arity.setLexicalHook(this);
            buffer.addLast(arity);
            return;
        } else {
            generateArity(buffer);
            generateExpressions(buffer);
        }
    }
}
